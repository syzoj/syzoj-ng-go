// Code generated by SQLBoiler 3.5.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// JudgeState is an object representing the database table.
type JudgeState struct {
	ID          int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	Code        null.String `boil:"code" json:"code,omitempty" toml:"code" yaml:"code,omitempty"`
	Language    null.String `boil:"language" json:"language,omitempty" toml:"language" yaml:"language,omitempty"`
	Status      null.String `boil:"status" json:"status,omitempty" toml:"status" yaml:"status,omitempty"`
	TaskID      null.String `boil:"task_id" json:"task_id,omitempty" toml:"task_id" yaml:"task_id,omitempty"`
	Score       null.Int    `boil:"score" json:"score,omitempty" toml:"score" yaml:"score,omitempty"`
	TotalTime   null.Int    `boil:"total_time" json:"total_time,omitempty" toml:"total_time" yaml:"total_time,omitempty"`
	CodeLength  null.Int    `boil:"code_length" json:"code_length,omitempty" toml:"code_length" yaml:"code_length,omitempty"`
	Pending     null.Int8   `boil:"pending" json:"pending,omitempty" toml:"pending" yaml:"pending,omitempty"`
	MaxMemory   null.Int    `boil:"max_memory" json:"max_memory,omitempty" toml:"max_memory" yaml:"max_memory,omitempty"`
	Compilation null.String `boil:"compilation" json:"compilation,omitempty" toml:"compilation" yaml:"compilation,omitempty"`
	Result      null.String `boil:"result" json:"result,omitempty" toml:"result" yaml:"result,omitempty"`
	UserID      null.Int    `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	ProblemID   null.Int    `boil:"problem_id" json:"problem_id,omitempty" toml:"problem_id" yaml:"problem_id,omitempty"`
	SubmitTime  null.Int    `boil:"submit_time" json:"submit_time,omitempty" toml:"submit_time" yaml:"submit_time,omitempty"`
	Type        null.Int    `boil:"type" json:"type,omitempty" toml:"type" yaml:"type,omitempty"`
	TypeInfo    null.Int    `boil:"type_info" json:"type_info,omitempty" toml:"type_info" yaml:"type_info,omitempty"`
	IsPublic    null.Int8   `boil:"is_public" json:"is_public,omitempty" toml:"is_public" yaml:"is_public,omitempty"`

	R *judgeStateR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L judgeStateL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var JudgeStateColumns = struct {
	ID          string
	Code        string
	Language    string
	Status      string
	TaskID      string
	Score       string
	TotalTime   string
	CodeLength  string
	Pending     string
	MaxMemory   string
	Compilation string
	Result      string
	UserID      string
	ProblemID   string
	SubmitTime  string
	Type        string
	TypeInfo    string
	IsPublic    string
}{
	ID:          "id",
	Code:        "code",
	Language:    "language",
	Status:      "status",
	TaskID:      "task_id",
	Score:       "score",
	TotalTime:   "total_time",
	CodeLength:  "code_length",
	Pending:     "pending",
	MaxMemory:   "max_memory",
	Compilation: "compilation",
	Result:      "result",
	UserID:      "user_id",
	ProblemID:   "problem_id",
	SubmitTime:  "submit_time",
	Type:        "type",
	TypeInfo:    "type_info",
	IsPublic:    "is_public",
}

// Generated where

var JudgeStateWhere = struct {
	ID          whereHelperint
	Code        whereHelpernull_String
	Language    whereHelpernull_String
	Status      whereHelpernull_String
	TaskID      whereHelpernull_String
	Score       whereHelpernull_Int
	TotalTime   whereHelpernull_Int
	CodeLength  whereHelpernull_Int
	Pending     whereHelpernull_Int8
	MaxMemory   whereHelpernull_Int
	Compilation whereHelpernull_String
	Result      whereHelpernull_String
	UserID      whereHelpernull_Int
	ProblemID   whereHelpernull_Int
	SubmitTime  whereHelpernull_Int
	Type        whereHelpernull_Int
	TypeInfo    whereHelpernull_Int
	IsPublic    whereHelpernull_Int8
}{
	ID:          whereHelperint{field: "`judge_state`.`id`"},
	Code:        whereHelpernull_String{field: "`judge_state`.`code`"},
	Language:    whereHelpernull_String{field: "`judge_state`.`language`"},
	Status:      whereHelpernull_String{field: "`judge_state`.`status`"},
	TaskID:      whereHelpernull_String{field: "`judge_state`.`task_id`"},
	Score:       whereHelpernull_Int{field: "`judge_state`.`score`"},
	TotalTime:   whereHelpernull_Int{field: "`judge_state`.`total_time`"},
	CodeLength:  whereHelpernull_Int{field: "`judge_state`.`code_length`"},
	Pending:     whereHelpernull_Int8{field: "`judge_state`.`pending`"},
	MaxMemory:   whereHelpernull_Int{field: "`judge_state`.`max_memory`"},
	Compilation: whereHelpernull_String{field: "`judge_state`.`compilation`"},
	Result:      whereHelpernull_String{field: "`judge_state`.`result`"},
	UserID:      whereHelpernull_Int{field: "`judge_state`.`user_id`"},
	ProblemID:   whereHelpernull_Int{field: "`judge_state`.`problem_id`"},
	SubmitTime:  whereHelpernull_Int{field: "`judge_state`.`submit_time`"},
	Type:        whereHelpernull_Int{field: "`judge_state`.`type`"},
	TypeInfo:    whereHelpernull_Int{field: "`judge_state`.`type_info`"},
	IsPublic:    whereHelpernull_Int8{field: "`judge_state`.`is_public`"},
}

// JudgeStateRels is where relationship names are stored.
var JudgeStateRels = struct {
}{}

// judgeStateR is where relationships are stored.
type judgeStateR struct {
}

// NewStruct creates a new relationship struct
func (*judgeStateR) NewStruct() *judgeStateR {
	return &judgeStateR{}
}

// judgeStateL is where Load methods for each relationship are stored.
type judgeStateL struct{}

var (
	judgeStateAllColumns            = []string{"id", "code", "language", "status", "task_id", "score", "total_time", "code_length", "pending", "max_memory", "compilation", "result", "user_id", "problem_id", "submit_time", "type", "type_info", "is_public"}
	judgeStateColumnsWithoutDefault = []string{"code", "language", "status", "task_id", "compilation", "result", "user_id", "problem_id", "submit_time", "type", "type_info", "is_public"}
	judgeStateColumnsWithDefault    = []string{"id", "score", "total_time", "code_length", "pending", "max_memory"}
	judgeStatePrimaryKeyColumns     = []string{"id"}
)

type (
	// JudgeStateSlice is an alias for a slice of pointers to JudgeState.
	// This should generally be used opposed to []JudgeState.
	JudgeStateSlice []*JudgeState
	// JudgeStateHook is the signature for custom JudgeState hook methods
	JudgeStateHook func(context.Context, boil.ContextExecutor, *JudgeState) error

	judgeStateQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	judgeStateType                 = reflect.TypeOf(&JudgeState{})
	judgeStateMapping              = queries.MakeStructMapping(judgeStateType)
	judgeStatePrimaryKeyMapping, _ = queries.BindMapping(judgeStateType, judgeStateMapping, judgeStatePrimaryKeyColumns)
	judgeStateInsertCacheMut       sync.RWMutex
	judgeStateInsertCache          = make(map[string]insertCache)
	judgeStateUpdateCacheMut       sync.RWMutex
	judgeStateUpdateCache          = make(map[string]updateCache)
	judgeStateUpsertCacheMut       sync.RWMutex
	judgeStateUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var judgeStateBeforeInsertHooks []JudgeStateHook
var judgeStateBeforeUpdateHooks []JudgeStateHook
var judgeStateBeforeDeleteHooks []JudgeStateHook
var judgeStateBeforeUpsertHooks []JudgeStateHook

var judgeStateAfterInsertHooks []JudgeStateHook
var judgeStateAfterSelectHooks []JudgeStateHook
var judgeStateAfterUpdateHooks []JudgeStateHook
var judgeStateAfterDeleteHooks []JudgeStateHook
var judgeStateAfterUpsertHooks []JudgeStateHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *JudgeState) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *JudgeState) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *JudgeState) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *JudgeState) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *JudgeState) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *JudgeState) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *JudgeState) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *JudgeState) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *JudgeState) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range judgeStateAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddJudgeStateHook registers your hook function for all future operations.
func AddJudgeStateHook(hookPoint boil.HookPoint, judgeStateHook JudgeStateHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		judgeStateBeforeInsertHooks = append(judgeStateBeforeInsertHooks, judgeStateHook)
	case boil.BeforeUpdateHook:
		judgeStateBeforeUpdateHooks = append(judgeStateBeforeUpdateHooks, judgeStateHook)
	case boil.BeforeDeleteHook:
		judgeStateBeforeDeleteHooks = append(judgeStateBeforeDeleteHooks, judgeStateHook)
	case boil.BeforeUpsertHook:
		judgeStateBeforeUpsertHooks = append(judgeStateBeforeUpsertHooks, judgeStateHook)
	case boil.AfterInsertHook:
		judgeStateAfterInsertHooks = append(judgeStateAfterInsertHooks, judgeStateHook)
	case boil.AfterSelectHook:
		judgeStateAfterSelectHooks = append(judgeStateAfterSelectHooks, judgeStateHook)
	case boil.AfterUpdateHook:
		judgeStateAfterUpdateHooks = append(judgeStateAfterUpdateHooks, judgeStateHook)
	case boil.AfterDeleteHook:
		judgeStateAfterDeleteHooks = append(judgeStateAfterDeleteHooks, judgeStateHook)
	case boil.AfterUpsertHook:
		judgeStateAfterUpsertHooks = append(judgeStateAfterUpsertHooks, judgeStateHook)
	}
}

// One returns a single judgeState record from the query.
func (q judgeStateQuery) One(ctx context.Context, exec boil.ContextExecutor) (*JudgeState, error) {
	o := &JudgeState{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for judge_state")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all JudgeState records from the query.
func (q judgeStateQuery) All(ctx context.Context, exec boil.ContextExecutor) (JudgeStateSlice, error) {
	var o []*JudgeState

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to JudgeState slice")
	}

	if len(judgeStateAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all JudgeState records in the query.
func (q judgeStateQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count judge_state rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q judgeStateQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if judge_state exists")
	}

	return count > 0, nil
}

// JudgeStates retrieves all the records using an executor.
func JudgeStates(mods ...qm.QueryMod) judgeStateQuery {
	mods = append(mods, qm.From("`judge_state`"))
	return judgeStateQuery{NewQuery(mods...)}
}

// FindJudgeState retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindJudgeState(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*JudgeState, error) {
	judgeStateObj := &JudgeState{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `judge_state` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, judgeStateObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from judge_state")
	}

	return judgeStateObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *JudgeState) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no judge_state provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(judgeStateColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	judgeStateInsertCacheMut.RLock()
	cache, cached := judgeStateInsertCache[key]
	judgeStateInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			judgeStateAllColumns,
			judgeStateColumnsWithDefault,
			judgeStateColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(judgeStateType, judgeStateMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(judgeStateType, judgeStateMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `judge_state` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `judge_state` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `judge_state` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, judgeStatePrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into judge_state")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == judgeStateMapping["ID"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for judge_state")
	}

CacheNoHooks:
	if !cached {
		judgeStateInsertCacheMut.Lock()
		judgeStateInsertCache[key] = cache
		judgeStateInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the JudgeState.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *JudgeState) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	judgeStateUpdateCacheMut.RLock()
	cache, cached := judgeStateUpdateCache[key]
	judgeStateUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			judgeStateAllColumns,
			judgeStatePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update judge_state, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `judge_state` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, judgeStatePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(judgeStateType, judgeStateMapping, append(wl, judgeStatePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update judge_state row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for judge_state")
	}

	if !cached {
		judgeStateUpdateCacheMut.Lock()
		judgeStateUpdateCache[key] = cache
		judgeStateUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q judgeStateQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for judge_state")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for judge_state")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o JudgeStateSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), judgeStatePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `judge_state` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, judgeStatePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in judgeState slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all judgeState")
	}
	return rowsAff, nil
}

var mySQLJudgeStateUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *JudgeState) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no judge_state provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(judgeStateColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLJudgeStateUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	judgeStateUpsertCacheMut.RLock()
	cache, cached := judgeStateUpsertCache[key]
	judgeStateUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			judgeStateAllColumns,
			judgeStateColumnsWithDefault,
			judgeStateColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			judgeStateAllColumns,
			judgeStatePrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert judge_state, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "judge_state", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `judge_state` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(judgeStateType, judgeStateMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(judgeStateType, judgeStateMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for judge_state")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == judgeStateMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(judgeStateType, judgeStateMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for judge_state")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}

	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for judge_state")
	}

CacheNoHooks:
	if !cached {
		judgeStateUpsertCacheMut.Lock()
		judgeStateUpsertCache[key] = cache
		judgeStateUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single JudgeState record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *JudgeState) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no JudgeState provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), judgeStatePrimaryKeyMapping)
	sql := "DELETE FROM `judge_state` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from judge_state")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for judge_state")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q judgeStateQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no judgeStateQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from judge_state")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for judge_state")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o JudgeStateSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(judgeStateBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), judgeStatePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `judge_state` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, judgeStatePrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from judgeState slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for judge_state")
	}

	if len(judgeStateAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *JudgeState) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindJudgeState(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *JudgeStateSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := JudgeStateSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), judgeStatePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `judge_state`.* FROM `judge_state` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, judgeStatePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in JudgeStateSlice")
	}

	*o = slice

	return nil
}

// JudgeStateExists checks if the JudgeState row exists.
func JudgeStateExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `judge_state` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if judge_state exists")
	}

	return exists, nil
}
